<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>合肥工业大学程艺小组演示——E题</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <style>
    :root{
      --gap: 16px;
      --panel-radius: 12px;
      --brand-1: #667eea;
      --brand-2: #764ba2;
      --text-1: #334155;
      --muted-1: #e9ecef;
    }
    *{margin:0;padding:0;box-sizing:border-box}
    html, body { height: 100%; }
    body{
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, var(--brand-1) 0%, var(--brand-2) 100%);
      color:#333;
      padding: 10px;
      overflow: hidden;
    }
    .container{
      height: calc(100vh - 20px);
      background:#fff;
      border-radius: 15px;
      box-shadow: 0 20px 60px rgba(0,0,0,.3);
      display:flex;
      flex-direction:column;
      overflow: hidden;
    }
    header{
      padding: 14px 16px;
      background: linear-gradient(135deg, var(--brand-1) 0%, var(--brand-2) 100%);
      color:#fff;
      text-align:center;
      flex-shrink:0;
    }
    header h1{ font-size: clamp(18px, 2.2vw, 28px); margin-bottom:6px; text-shadow:2px 2px 4px rgba(0,0,0,.2) }
    header h3{ font-size: clamp(12px, 1.1vw, 16px); font-weight:300; opacity:.95 }

    .main{
      flex:1;
      display:grid;
      grid-template-columns: minmax(520px, 2fr) minmax(320px, 1fr);
      gap: var(--gap);
      padding: var(--gap);
      overflow: hidden;
    }
    @media (max-width: 1024px){
      .main{ grid-template-columns: 1fr; }
    }

    .stage{
      border: 3px solid #e0e0e0;
      border-radius: var(--panel-radius);
      background:#fafafa;
      position: relative;
      overflow: hidden;
      min-height: clamp(440px, 60vh, 820px);
    }
    .stage .wrap{ position:relative; width:100%; height:100%; }
    svg{ width:100%; height:100%; display:block; }

    .info{
      background:#f8f9fa;
      border-radius: var(--panel-radius);
      border: 2px solid var(--muted-1);
      padding: clamp(12px, 1.8vw, 18px);
      overflow: auto;
      min-height: 240px;
    }
    .info h2{ color: var(--brand-1); margin-bottom: 10px; font-size: clamp(16px, 1.6vw, 22px) }
    .info h3{ color: var(--brand-2); margin-top: 12px; margin-bottom: 8px; font-size: clamp(14px, 1.4vw, 20px) }
    .info h4{ color: #555; margin-top: 10px; margin-bottom: 6px; font-size: clamp(13px, 1.2vw, 18px) }
    .info p{ line-height: 1.8; font-size: clamp(13px, 1.1vw, 16px); margin-bottom: 8px }
    .info code{ background:#eef2ff; padding:2px 6px; border-radius:4px; color:#7c3aed }
    .problem-box{
      border: 2px solid var(--brand-1);
      border-radius: 10px;
      background: #fff;
      padding: 14px;
      margin: 8px 0;
      font-size: clamp(12px, 1vw, 15px);
      line-height: 1.75;
      white-space: pre-wrap;
    }
    .sample-box{
      background: #f8f9fa;
      padding: 8px 12px;
      border-radius: 6px;
      margin: 6px 0;
      font-family: 'Courier New', monospace;
      font-size: clamp(11px, 0.95vw, 14px);
    }

    .controls{
      padding: 10px 14px;
      background:#f8f9fa;
      display:flex; justify-content:center; gap: 14px;
      flex-shrink:0;
    }
    .btn{
      background: linear-gradient(135deg, var(--brand-1) 0%, var(--brand-2) 100%);
      color:#fff; border:none;
      padding: 10px 28px;
      font-size: clamp(13px,1.1vw,16px);
      border-radius: 50px;
      cursor: pointer;
      transition: all .22s ease;
      box-shadow: 0 4px 14px rgba(102,126,234,.4);
      font-weight: 600;
    }
    .btn:hover:not(:disabled){ transform: translateY(-1px); box-shadow: 0 6px 18px rgba(102,126,234,.55); }
    .btn:disabled{ background:#cbd5e1; cursor:not-allowed; box-shadow:none; opacity:.85; }
    .btn.prev{ background: linear-gradient(135deg, #718096 0%, #4a5568 100%) }

    .node{ transition: all .25s ease }
    .node circle{ stroke-width: 2 }
    .node.type-0 circle{ fill: #3498db; stroke: #2980b9 }
    .node.type-1 circle{ fill: #e67e22; stroke: #d35400 }
    .node.highlighted circle{ stroke:#2ecc71; stroke-width:4; filter: drop-shadow(0 0 8px #2ecc71) }
    .node.pulsing circle{ animation: pulse 1.5s ease-in-out infinite }
    @keyframes pulse{ 0%,100%{ stroke-width:4; filter: drop-shadow(0 0 8px #2ecc71) } 50%{ stroke-width:6; filter: drop-shadow(0 0 14px #2ecc71) } }
    .node text{ fill: #fff; font-size: 14px; font-weight: 700; text-anchor: middle; dominant-baseline: middle; pointer-events:none }

    .edge{ transition: all .25s ease }
    .edge.x{ stroke:#e74c3c; stroke-width:4 }
    .edge.y{ stroke:#3498db; stroke-width:4 }
    .edge.highlighted{ stroke-width:6; filter: drop-shadow(0 0 4px currentColor) }

    .axis-label{ font-size: clamp(12px, 1vw, 16px); font-weight: 700; fill:#667085 }

    .state-edge{ stroke-width:4; opacity:.9 }
    .state-edge.x{ stroke:#e74c3c }
    .state-edge.y{ stroke:#3498db }
    .state-edge.highlighted{ stroke-width:6; filter: drop-shadow(0 0 6px currentColor) }

    .state-node circle{ fill:#fff; stroke:#cbd5e0; stroke-width:2; transition: all .25s ease }
    .state-node.visited circle{ fill:#e3f2fd; stroke:#3498db }
    .state-node.current circle{ stroke:#2ecc71; stroke-width:4; filter: drop-shadow(0 0 8px #2ecc71) }
    .state-node.target circle{ fill:#ffd700; stroke:#f39c12; stroke-width:4 }
    .state-node.path circle{ fill:#fffbcc; stroke:#facc15; stroke-width:3 }
    .state-node text{ font-size: clamp(10px, .9vw, 12px); fill:#334155; font-weight: 700; text-anchor: middle; dominant-baseline: middle; pointer-events:none }

    .state-label{ font-size: clamp(16px, 1.8vw, 24px); font-weight: 800; fill:#4f46e5; }

    .queue-fo .q{
      background:#fff; border:3px solid var(--brand-1); border-radius:10px; padding: 10px 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,.15);
      display:inline-flex; flex-direction: column; gap:8px;
    }
    .queue-fo .t{ font-weight: 800; color: var(--brand-1); text-align:center }
    .queue-fo .items{ display:flex; gap:8px; flex-wrap:wrap }
    .queue-fo .it{ background:#e3f2fd; border:2px solid #3498db; border-radius:6px; padding:6px 8px; font-size:13px; font-weight:700; color:#1f2937 }

    .code-wrap{ position:absolute; inset: 0; padding: 12px; }
    .code-box{
      width:100%; height:100%; background:#0b1020; color:#cbd5e1; border-radius: 10px; overflow:auto;
      padding: 18px; font-family: Consolas, Monaco, "Courier New", monospace; line-height:1.6; white-space:pre; font-size: 13.5px;
    }
    .kw{ color:#c678dd } .ty{ color:#e5c07b } .fn{ color:#61afef } .num{ color:#d19a66 } .cm{ color:#636e7b; font-style:italic }

    .fade-in{ animation: fadeIn .45s ease-out }
    @keyframes fadeIn{ from{ opacity:0; transform: translateY(8px) } to{ opacity:1; transform:none } }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>合肥工业大学程艺小组演示——E题</h1>
      <h3>组员: 李昊 周骏浩 叶豪杰 姚睿</h3>
    </header>

    <div class="main">
      <div class="stage">
        <div class="wrap">
          <svg id="canvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet">
            <g id="layer-city"></g>
            <g id="layer-state-label"></g>
            <g id="layer-topo"></g>
            <g id="layer-queue"></g>
            <g id="layer-code"></g>
          </svg>
        </div>
      </div>

      <div class="info">
        <div id="info-content"></div>
      </div>
    </div>

    <div class="controls">
      <button class="btn prev" id="btn-prev" disabled>上一步</button>
      <button class="btn" id="btn-next">下一步</button>
    </div>
  </div>

  <script>
    let scene = 0;

    // ========== 示例配置 ==========
    const EXAMPLES = {
      solvable: {
        rows: 4, cols: 4,
        A: 0, B: 5,
        type: [0,1,1,0, 1,0,1,0, 0,1,0,1, 1,0,1,0]
      },
      unsolvable: {
        rows: 3, cols: 3,
        A: 0, B: 4,
        type: [0,1,0, 1,0,1, 0,1,0]
      }
    };

    let currentExample = 'solvable';
    let config, rows, cols, N, A0, B0, type, xTo, yTo;

    function loadExample(name){
      currentExample = name;
      config = EXAMPLES[name];
      rows = config.rows;
      cols = config.cols;
      N = rows * cols;
      A0 = config.A;
      B0 = config.B;
      type = config.type;
      xTo = Array(N); yTo = Array(N);
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const id = r*cols + c;
          xTo[id] = r*cols + ((c+1) % cols);
          yTo[id] = ((r+1) % rows) * cols + c;
        }
      }
    }
    loadExample('solvable');

    const CELL = 120;
    const CENTER_X = 600, CENTER_Y = 350;
    
    function getOffsets(){
      return {
        x: CENTER_X - (cols * CELL)/2,
        y: CENTER_Y - (rows * CELL)/2
      };
    }

    let posA = A0, posB = B0;

    const svg = document.getElementById('canvas');
    const layerCity = document.getElementById('layer-city');
    const layerStateLabel = document.getElementById('layer-state-label');
    const layerTopo = document.getElementById('layer-topo');
    const layerQueue = document.getElementById('layer-queue');
    const layerCode = document.getElementById('layer-code');
    const infoBox = document.getElementById('info-content');
    const btnPrev = document.getElementById('btn-prev');
    const btnNext = document.getElementById('btn-next');

    let katexReady = false;
    function waitKatex(){
      return new Promise(res=>{
        if (window.renderMathInElement){ katexReady = true; res(); }
        else setTimeout(()=>waitKatex().then(res), 100);
      });
    }

    function setInfo(html){
      infoBox.innerHTML = html;
      if (katexReady && window.renderMathInElement){
        renderMathInElement(infoBox, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false }
          ],
          throwOnError: false
        });
      }
    }
    
    function el(tag, attrs={}){ 
      const e = document.createElementNS('http://www.w3.org/2000/svg', tag); 
      for (const k in attrs) e.setAttribute(k, attrs[k]); 
      return e; 
    }
    
    function rcOf(id){ return { r: Math.floor(id/cols), c: id % cols }; }
    function xyOf(id){ 
      const {r,c}=rcOf(id);
      const off = getOffsets();
      return { x: off.x + c*CELL + CELL/2, y: off.y + r*CELL + CELL/2 }; 
    }
    
    function show(g, on=true){ g.style.display = on ? 'block' : 'none'; }
    function cls(g){ while (g.firstChild) g.removeChild(g.firstChild); }
    function hideAll(){ 
      [layerCity, layerStateLabel, layerTopo, layerQueue, layerCode].forEach(g=>show(g,false)); 
    }

    function fitViewBoxToVisible(padding=40){
      const visibleLayers = [layerCity, layerStateLabel, layerTopo, layerQueue, layerCode]
        .filter(g => g.style.display !== 'none' && g.childNodes.length > 0);
      if (visibleLayers.length === 0) return; 
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      visibleLayers.forEach(g=>{
        try{
          const bb = g.getBBox();
          if (!bb || !isFinite(bb.x)) return;
          minX = Math.min(minX, bb.x);
          minY = Math.min(minY, bb.y);
          maxX = Math.max(maxX, bb.x + bb.width);
          maxY = Math.max(maxY, bb.y + bb.height);
        }catch(e){}
      });
      if (!isFinite(minX)) return;
      const w = Math.max(600, (maxX - minX) + 2*padding);
      const h = Math.max(380, (maxY - minY) + 2*padding);
      svg.setAttribute('viewBox', `${minX - padding} ${minY - padding} ${w} ${h}`);
    }

    // ========== 绘制函数 ==========
    function drawCity(){
      cls(layerCity);
      const off = getOffsets();
      
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const id = r*cols + c;
          const to = xTo[id];
          const p1 = xyOf(id), p2 = xyOf(to);
          layerCity.appendChild(el('line', { 
            x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y, 
            class:'edge x', 'data-from':id, 'data-to':to, 'data-m':'x' 
          }));
        }
      }
      
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const id = r*cols + c;
          const to = yTo[id];
          const p1 = xyOf(id), p2 = xyOf(to);
          layerCity.appendChild(el('line', { 
            x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y, 
            class:'edge y', 'data-from':id, 'data-to':to, 'data-m':'y' 
          }));
        }
      }
      
      for (let id=0; id<N; id++){
        const p = xyOf(id);
        const g = el('g', { class:`node type-${type[id]}`, 'data-id':id });
        g.appendChild(el('circle', { cx:p.x, cy:p.y, r: 22 }));
        const tx = el('text', { x:p.x, y:p.y }); 
        tx.textContent = id;
        g.appendChild(tx);
        layerCity.appendChild(g);
      }
      
      const gw = cols * CELL, gh = rows * CELL;
      const xLbl = el('text', { x: off.x + gw/2, y: off.y + gh + 40, class:'axis-label' });
      xLbl.textContent = 'X 方向（向右环绕）'; 
      xLbl.setAttribute('text-anchor','middle'); 
      layerCity.appendChild(xLbl);
      
      const yLbl = el('text', { x: off.x - 74, y: off.y + gh/2, class:'axis-label' });
      yLbl.textContent = 'Y 方向（向下环绕）'; 
      yLbl.setAttribute('transform', `rotate(-90, ${off.x - 74}, ${off.y + gh/2})`);
      layerCity.appendChild(yLbl);
    }
    
    function highlightNodes(ids=[], pulsing=false){
      layerCity.querySelectorAll('.node').forEach(n=>n.classList.remove('highlighted','pulsing'));
      ids.forEach(id=>{
        const g = layerCity.querySelector(`.node[data-id="${id}"]`);
        if (g){
          g.classList.add('highlighted');
          if (pulsing) g.classList.add('pulsing');
        }
      });
    }
    
    function highlightEdge(from, to, m){ 
      const e = layerCity.querySelector(`.edge[data-from="${from}"][data-to="${to}"][data-m="${m}"]`);
      if (e) e.classList.add('highlighted');
    }

    function drawStateLabel(u, v){
      cls(layerStateLabel);
      const off = getOffsets();
      const t = el('text', { x: CENTER_X, y: off.y - 24, class:'state-label' });
      t.setAttribute('text-anchor', 'middle');
      t.textContent = `状态 (${u}, ${v})`;
      layerStateLabel.appendChild(t);
    }

    // ========== 状态拓扑 ==========
    const K = (u,v)=>`${u},${v}`;

    function buildTopoComplex({ maxDepth=3, maxNodes=20 } = {}){
      const start = K(A0,B0);
      const nodes = new Map();    
      const levels = new Map();   
      const edges = [];           

      const q = [ start ];
      nodes.set(start, { u:A0, v:B0, depth:0 });
      levels.set(0, [start]);

      const pushLevel = (d, k) => {
        if (!levels.has(d)) levels.set(d, []);
        levels.get(d).push(k);
      };

      let head = 0;
      while (head < q.length){
        const cur = q[head++];
        const {u,v, depth} = nodes.get(cur);
        if (depth >= maxDepth) continue;

        const nexts = [
          { key: K(xTo[u], xTo[v]), u: xTo[u], v: xTo[v], type:'x' },
          { key: K(yTo[u], yTo[v]), u: yTo[u], v: yTo[v], type:'y' },
        ];

        for (const nb of nexts){
          if (!nodes.has(nb.key)){
            if (nodes.size >= maxNodes) continue;
            nodes.set(nb.key, { u: nb.u, v: nb.v, depth: depth+1 });
            q.push(nb.key);
            pushLevel(depth+1, nb.key);
          }
          if (!edges.some(e => (e.a===cur && e.b===nb.key) || (e.a===nb.key && e.b===cur))){
            edges.push({ a: cur, b: nb.key, type: nb.type });
          }
        }
        if (nodes.size >= maxNodes) break;
      }

      const pos = new Map();
      const dy = 110;
      const y0 = CENTER_Y - (Math.min(maxDepth, levels.size-1) * dy)/2;
      const marginX = 110;

      Array.from(levels.keys()).sort((a,b)=>a-b).forEach((d, idx)=>{
        const arr = levels.get(d);
        const totalW = (arr.length - 1) * marginX;
        const x0 = CENTER_X - totalW/2;
        arr.forEach((k, i)=>{
          pos.set(k, { x: x0 + i * marginX, y: y0 + idx * dy });
        });
      });

      const nodeArr = Array.from(nodes.entries()).map(([k, v]) => ({ key:k, u:v.u, v:v.v, depth:v.depth }));
      return { nodes: nodeArr, edges, pos };
    }

    function drawTopo(topo){
      cls(layerTopo);
      topo.edges.forEach(e=>{
        const p1 = topo.pos.get(e.a), p2 = topo.pos.get(e.b);
        layerTopo.appendChild(el('line', {
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
          class: `state-edge ${e.type}`,
          'data-a': e.a, 'data-b': e.b, 'data-type': e.type
        }));
      });
      topo.nodes.forEach(s=>{
        const p = topo.pos.get(s.key);
        const g = el('g', { class:'state-node', 'data-k': s.key });
        g.appendChild(el('circle', { cx: p.x, cy: p.y, r: 20 }));
        const tx = el('text', { x: p.x, y: p.y }); 
        tx.textContent = `(${s.u},${s.v})`;
        g.appendChild(tx);
        layerTopo.appendChild(g);
      });
    }
    
    function topoNode(k){ return layerTopo.querySelector(`.state-node[data-k="${k}"]`); }
    function topoEdge(a,b,type){
      return layerTopo.querySelector(`.state-edge[data-a="${a}"][data-b="${b}"][data-type="${type}"]`) ||
             layerTopo.querySelector(`.state-edge[data-a="${b}"][data-b="${a}"][data-type="${type}"]`);
    }
    function markNode(k, mode){ 
      const n = topoNode(k); 
      if (n){ 
        n.classList.remove('visited','current','target','path'); 
        n.classList.add(mode); 
      } 
    }
    function addDistLabel(topo, k, d){
      const p = topo.pos.get(k);
      const t = el('text', { x: p.x, y: p.y - 28, class:'state-node' });
      t.style.fontSize = '13px'; 
      t.style.fontWeight = '800'; 
      t.style.fill = '#667eea';
      t.textContent = String(d);
      layerTopo.appendChild(t);
    }
    function glowEdge(a,b,type,on=true){ 
      const e = topoEdge(a,b,type); 
      if (e){ 
        if (on) e.classList.add('highlighted'); 
        else e.classList.remove('highlighted'); 
      } 
    }

    function drawQueue(queue, distMap){
      cls(layerQueue);
      const fo = el('foreignObject', { 
        x: CENTER_X - 220, y: CENTER_Y + 180, width: 440, height: 150, class:'queue-fo' 
      });
      const div = document.createElement('div'); div.className = 'q';
      const t = document.createElement('div'); t.className = 't'; t.textContent = 'BFS 队列';
      const items = document.createElement('div'); items.className = 'items';
      
      if (!queue || queue.length === 0){
        const it = document.createElement('div'); 
        it.className = 'it'; it.style.opacity = '.6'; it.textContent = '(空)';
        items.appendChild(it);
      }else{
        queue.forEach(k=>{
          const it = document.createElement('div'); it.className='it';
          it.textContent = `${k}:${distMap.get(k) ?? '?'}`;
          items.appendChild(it);
        });
      }
      div.appendChild(t); div.appendChild(items); fo.appendChild(div); layerQueue.appendChild(fo);
    }

    function drawCode(){
      cls(layerCode);
      const fo = el('foreignObject', { x: 20, y: 20, width: 1160, height: 660 });
      const wrap = document.createElement('div'); wrap.className = 'code-wrap fade-in';
      const pre = document.createElement('pre'); pre.className = 'code-box';
      pre.innerHTML =
`<span class="cm">// 在抽象的状态图上执行 BFS，首次发现类型不同即为最短步数</span>
<span class="ty">int</span> <span class="fn">solve</span>(<span class="ty">int</span> A, <span class="ty">int</span> B,
         <span class="ty">const vector</span>&lt;<span class="ty">int</span>&gt;& x,
         <span class="ty">const vector</span>&lt;<span class="ty">int</span>&gt;& y,
         <span class="ty">const vector</span>&lt;<span class="ty">int</span>&gt;& type) {
  <span class="ty">queue</span>&lt;<span class="ty">pair</span>&lt;<span class="ty">int</span>,<span class="ty">int</span>&gt;&gt; q;
  <span class="ty">unordered_map</span>&lt;<span class="ty">long long</span>, <span class="ty">int</span>&gt; dist;

  <span class="kw">auto</span> <span class="fn">key</span> = [](<span class="ty">int</span> u, <span class="ty">int</span> v){ <span class="kw">return</span> ((<span class="ty">long long</span>)u&lt;&lt;32) ^ (unsigned)v; };

  q.push({A, B});
  dist[key(A,B)] = <span class="num">0</span>;

  <span class="kw">while</span>(!q.empty()) {
    <span class="kw">auto</span> [u, v] = q.front(); q.pop();
    <span class="ty">int</span> d = dist[key(u,v)];

    <span class="cm">// 目标：两点类型不同</span>
    <span class="kw">if</span> (type[u] != type[v]) <span class="kw">return</span> d;

    <span class="cm">// 两种同步移动</span>
    {
      <span class="ty">int</span> nu = x[u], nv = x[v];
      <span class="ty">long long</span> k = key(nu,nv);
      <span class="kw">if</span> (!dist.count(k)) { dist[k] = d + <span class="num">1</span>; q.push({nu,nv}); }
    }
    {
      <span class="ty">int</span> nu = y[u], nv = y[v];
      <span class="ty">long long</span> k = key(nu,nv);
      <span class="kw">if</span> (!dist.count(k)) { dist[k] = d + <span class="num">1</span>; q.push({nu,nv}); }
    }
  }
  <span class="kw">return</span> -<span class="num">1</span>; <span class="cm">// 无解</span>
}`;
      wrap.appendChild(pre); fo.appendChild(wrap); layerCode.appendChild(fo);
    }

    // ========== BFS 控制（修复：不提前判断队列为空）==========
    let topo = null;
    let bfs = null;

    function initBFS(){
      const startK = K(A0,B0);
      bfs = {
        q: [ startK ],
        dist: new Map([[startK, 0]]),
        prev: new Map(),
        via: new Map(),
        vis: new Set([ startK ]),
        found: null,
        finished: false
      };
    }

    function stepBFS(){
      if (!bfs || bfs.finished) {
        return { done: true, foundSolution: !!bfs?.found };
      }

      // 关键修复：只有当队列真正为空时才判断结束
      if (bfs.q.length === 0) {
        bfs.finished = true;
        return { done: true, foundSolution: false };
      }

      const cur = bfs.q.shift();
      const d0 = bfs.dist.get(cur);
      const [u,v] = cur.split(',').map(Number);
      
      markNode(cur, 'current');
      
      if (type[u] !== type[v]){
        bfs.found = cur;
        bfs.finished = true;
        return { done: true, foundSolution: true };
      }

      const neighbors = topo.edges
        .filter(e => e.a===cur || e.b===cur)
        .map(e => ({ key: e.a===cur ? e.b : e.a, type: e.type }));

      for (const nb of neighbors){
        const [nu,nv] = nb.key.split(',').map(Number);
        if (!bfs.vis.has(nb.key)){
          bfs.vis.add(nb.key);
          bfs.dist.set(nb.key, d0+1);
          bfs.prev.set(nb.key, cur);
          bfs.via.set(nb.key, nb.type);
          glowEdge(cur, nb.key, nb.type, true);
          
          if (type[nu] !== type[nv]){
            bfs.found = nb.key;
            bfs.finished = true;
            markNode(nb.key, 'target');
            addDistLabel(topo, nb.key, d0+1);
            return { done: true, foundSolution: true };
          }
          bfs.q.push(nb.key);
          markNode(nb.key, 'visited');
          addDistLabel(topo, nb.key, d0+1);
        }
      }

      // 修复：处理完当前节点后，继续检查队列
      // 不在这里判断finished，让下一次调用时判断
      return { done: false, foundSolution: false };
    }

    // ========== 场景控制 ==========
    function run(){
      hideAll();

      if (scene === 0){
        loadExample('solvable');
        posA = A0; posB = B0;
        setInfo(`
          <h2>场景0：题目描述（E 城市规划）</h2>
          <div class="problem-box"><h2>E 城市规划</h2>
在某市有 n 个路口，每个路口都连接着另外两个路口，可以向方向 X 行走到达某个路口，或向方向 Y 行走到达某个路口（可能相同也可能回到原地），所有的路口被分为两种类型（用 0/1 表示），路口编号为 0 到 n-1。

现在以"路口独特度"指标评价该市的城市规划合理性。从 A 和 B 两个路口出发，一直按照同样的方向模拟从 A 路口出发和从 B 路口出发走，直到走到种类不同的路口，所需要的最短步数就是"路口独特度"。

现在，给出该市的地图，请求出"路口独特度"。

<h3>输入说明：</h3>
输入包含多组数据，第一行输入数据组数 T。每组数据的输入如下：
第一行三个正整数：n,A,B（A≠B）
第二行到第 n+1 行每行三个整数：xi, yi, ti，表示路口 i 向方向 X 走到达路口 xi，向方向 Y 走到达路口 yi，它的种类为 ti。

<h3>输出说明：</h3>
如果能够判断，则输出最少步数，否则输出 GG 

<h3>输入样例：</h3><div class="sample-box">2 
3 1 2 
1 2 1 
0 2 0 
0 1 0 
3 1 2 
1 2 0 
2 0 1 
0 1 1 </div>
<h3>样例输出：</h3><div class="sample-box">GG 
1 </div>
<h3>数据范围：</h3>
∑n<=100000</div>
          <p>下图为<strong>有解示例</strong>：4×4网格，A=${A0}, B=${B0}。起始状态两位置类型：type(${A0})=${type[A0]}, type(${B0})=${type[B0]}。</p>
        `);
        drawCity(); show(layerCity,true);
        highlightNodes([A0,B0], true);
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 1){
        setInfo(`
          <h2>场景1：手动模拟（第1步 X）</h2>
          <p>第1步选择 X：A: ${A0} → ${xTo[A0]}，B: ${B0} → ${xTo[B0]}。</p>
          <p>类型检查：type(${xTo[A0]})=${type[xTo[A0]]}，type(${xTo[B0]})=${type[xTo[B0]]}，相同，继续。</p>
        `);
        show(layerCity,true);
        highlightNodes([A0,B0], true);
        highlightEdge(A0, xTo[A0], 'x'); 
        highlightEdge(B0, xTo[B0], 'x');
        setTimeout(()=>{
          posA = xTo[A0]; posB = xTo[B0];
          highlightNodes([posA,posB], true);
          fitViewBoxToVisible();
        }, 300);
      }
      else if (scene === 2){
        setInfo(`
          <h2>场景2：手动模拟（第2步 Y）</h2>
          <p>第2步选择 Y：A: ${posA} → ${yTo[posA]}，B: ${posB} → ${yTo[posB]}。</p>
          <p>手动模拟复杂且易错，引入"状态 (u,v)"抽象。</p>
        `);
        show(layerCity,true);
        highlightNodes([posA,posB], true);
        highlightEdge(posA, yTo[posA], 'y'); 
        highlightEdge(posB, yTo[posB], 'y');
        setTimeout(()=>{
          posA = yTo[posA]; posB = yTo[posB];
          highlightNodes([posA,posB], true);
          fitViewBoxToVisible();
        }, 300);
      }
      else if (scene === 3){
        setInfo(`
          <h2>场景3：状态抽象</h2>
          <p>将两个位置的组合 (u,v) 视为单一状态。</p>
        `);
        show(layerCity,true);
        highlightNodes([posA,posB], true);
        drawStateLabel(posA, posB); 
        show(layerStateLabel,true);
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 4){
        setInfo(`
          <h2>场景4：状态转移拓扑</h2>
          <p>同步移动对应状态间转移。下图展示状态拓扑结构。</p>
        `);
        topo = buildTopoComplex({ maxDepth: 3, maxNodes: 20 });
        drawTopo(topo); 
        show(layerTopo,true);
        const s0 = K(A0,B0), sx = K(xTo[A0], xTo[B0]), sy = K(yTo[A0], yTo[B0]);
        markNode(s0,'current');
        setTimeout(()=>{
          markNode(sx,'visited'); glowEdge(s0,sx,'x',true);
          markNode(sy,'visited'); glowEdge(s0,sy,'y',true);
          fitViewBoxToVisible();
        }, 300);
      }
      else if (scene === 5){
        setInfo(`
          <h2>场景5：BFS 初始化（有解案例）</h2>
          <p>起点 (${A0}, ${B0})，距离 0。起始状态类型：type(${A0})=${type[A0]}, type(${B0})=${type[B0]}（相同）。</p>
          <p>准备逐步扩展搜索类型不同的状态。</p>
        `);
        if (!topo) topo = buildTopoComplex({ maxDepth: 3, maxNodes: 20 });
        initBFS();
        
        drawTopo(topo); 
        show(layerTopo,true);
        const startK = K(A0,B0);
        markNode(startK,'visited'); 
        addDistLabel(topo, startK, 0);
        drawQueue(bfs.q, bfs.dist); 
        show(layerQueue,true);
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 6){
        if (!bfs || bfs.finished){
          scene = 7;
          run();
          return;
        }

        setInfo(`
          <h2>场景6：BFS 扩展（有解案例）</h2>
          <p>从队列取出状态，检查邻居，逐步扩展。当前队列长度：${bfs.q.length}，已访问：${bfs.vis.size} 个状态</p>
        `);
        
        show(layerTopo,true); show(layerQueue,true);
        
        const result = stepBFS();
        drawQueue(bfs.q, bfs.dist);
        fitViewBoxToVisible();

        if (result.done){
          setTimeout(()=>{
            scene = 7;
            run();
          }, 800);
        }
      }
      else if (scene === 7){
        setInfo(`
          <h2>场景7：有解案例结果</h2>
          <p><strong>找到解！最短步数：${bfs.dist.get(bfs.found)}</strong></p>
          <p>目标状态：${bfs.found}，黄色高亮。路径用黄绿色标注。</p>
        `);
        
        show(layerTopo,true); show(layerQueue,true);
        
        if (bfs.found){
          const path = [];
          let k = bfs.found;
          while (k){
            path.push(k);
            k = bfs.prev.get(k);
          }
          path.reverse();
          for (const pk of path) markNode(pk,'path');
          markNode(bfs.found,'target');
        }
        
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 8){
        loadExample('unsolvable');
        posA = A0; posB = B0;
        setInfo(`
          <h2>场景8：切换到无解案例</h2>
          <p><strong>无解示例</strong>：3×3网格，A=${A0}, B=${B0}。起始状态类型：type(${A0})=${type[A0]}, type(${B0})=${type[B0]}。</p>
          <p>在该配置下，所有可达状态的两位置类型始终相同，因此无解。</p>
        `);
        drawCity(); show(layerCity,true);
        highlightNodes([A0,B0], true);
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 9){
        setInfo(`
          <h2>场景9：BFS 初始化（无解案例）</h2>
          <p>起点 (${A0}, ${B0})，距离 0。起始状态类型：type(${A0})=${type[A0]}, type(${B0})=${type[B0]}（相同）。</p>
          <p>准备逐步扩展，将遍历所有可达状态。</p>
        `);
        topo = buildTopoComplex({ maxDepth: 2, maxNodes: 15 });
        initBFS();
        
        drawTopo(topo); 
        show(layerTopo,true);
        const startK = K(A0,B0);
        markNode(startK,'visited'); 
        addDistLabel(topo, startK, 0);
        drawQueue(bfs.q, bfs.dist); 
        show(layerQueue,true);
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 10){
        if (!bfs || bfs.finished){
          scene = 11;
          run();
          return;
        }

        setInfo(`
          <h2>场景10：BFS 扩展（无解案例）</h2>
          <p>从队列取出状态，检查邻居。当前队列长度：${bfs.q.length}，已访问：${bfs.vis.size} 个状态</p>
          <p>继续扩展，直到队列为空...</p>
        `);
        
        show(layerTopo,true); show(layerQueue,true);
        
        const result = stepBFS();
        drawQueue(bfs.q, bfs.dist);
        fitViewBoxToVisible();

        if (result.done){
          setTimeout(()=>{
            scene = 11;
            run();
          }, 800);
        }
      }
      else if (scene === 11){
        setInfo(`
          <h2>场景11：无解案例结果</h2>
          <p>队列耗尽，未找到类型不同的状态。已遍历所有可达状态共 ${bfs.vis.size} 个。</p>
          <p><strong>判定：无解（GG）</strong></p>
        `);
        show(layerTopo,true); show(layerQueue,true);
        setTimeout(fitViewBoxToVisible, 50);
      }
      else if (scene === 12){
        setInfo(`
          <h2>场景12：算法实现</h2>
          <p>在抽象状态图上运行标准 BFS。</p>
        `);
        drawCode(); 
        show(layerCode,true);
        setTimeout(fitViewBoxToVisible, 50);
      }

      updateButtons();
    }

    function updateButtons(){
      btnPrev.disabled = scene === 0;
      
      if ((scene === 6 || scene === 10) && bfs && !bfs.finished){
        btnNext.textContent = 'BFS下一步';
        btnNext.disabled = false;
      } else if (scene === 12){
        btnNext.textContent = '演示完成';
        btnNext.disabled = true;
      } else {
        btnNext.textContent = '下一步';
        btnNext.disabled = false;
      }
    }

    btnPrev.addEventListener('click', ()=>{ 
      if (scene > 0){
        if (scene === 6){
          scene = 5;
        } else if (scene === 7){
          scene = 6;
          initBFS();
        } else if (scene === 10){
          scene = 9;
        } else if (scene === 11){
          scene = 10;
          initBFS();
        } else {
          scene--;
        }
        run();
      }
    });
    
    btnNext.addEventListener('click', ()=>{ 
      if (scene === 6 && bfs && !bfs.finished){
        run();
      } else if (scene === 10 && bfs && !bfs.finished){
        run();
      } else if (scene < 12){
        scene++;
        run();
      }
    });

    waitKatex().then(run);

    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(fitViewBoxToVisible, 60);
    });
  </script>
</body>
</html>
